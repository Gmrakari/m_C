#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "A.h"

// 应用者B

void fCallBack(int a) { // 应用者增加的函数，此函数会在A中被执行
    // do something
    printf("B:start\r\n");
    printf("a = %d\r\n", a);
    sleep(5);
    printf("B:end\r\n");
}

void SetCallBackFun(int a, pcb callback);

// 回调函数:
// 回调函数一般是在封装接口的时候，显得特别重要
// 假设有两个程序员在写代码，A程序员写底层驱动接口，B程序员写上层应用程序，然而此时底层驱动接口A有一个数据data需要传输给B，此时有两种方式:
// 1、A将数据data存储好放在接口函数中，B自己想什么时候去读就什么时候去读，这就是我们经常使用的函数调用，此时主动权是B
// 2、A实现回调机制，当数据变化的时候才去通知B，你可以来读取数据了，然后B在用户层的回调函数中读取数据data,完成ok。此时主动权是A

// 第一种方法效率明显太低效了，B根本不知道什么时候该去调用接口函数读取数据data
// 而第二种方法由于B的读取数据操作是依赖A的，只有A叫B读数据，那么B才能读取数据。也即是实现了中断读取

// 那么回调是怎么实现的呢？其实回调函数就是一个通过函数指针调用的函数，如果用户层B把函数的指针（地址）作为参数传递给底层驱动A，
// 当这个指针在A中被用为调用它所指向的函数时，我们就说这是回调函数

// tips:是在A中被调用，这里看到尽管函数是在B中，但是B却不是自己调用这个函数，而是将这个函数的函数指针通过A的接口函数传到A中了，由A来操纵执行

int main() {
    SetCallBackFun(4, fCallBack);
    return 0;
}

/*
** run ret:
**
** A:start
** B:start
** a = 4
** B:end
** A:end
**
*/

// 同步回调和异步回调
// 1、回调可以是同步也可以是异步
// 2、同步可以是单线程也可以是多线程
// 异步必须是多线程或多进程(每个进程可以是单线程) ==> 异步必须依靠多线程或者多进程才能完成

// 同步回调:把函数b传递给函数a。执行a的时候，回调了b，a要一直等b执行完才能继续执行;
// 异步回调:把函数b传递给函数a。执行a的时候，回调了b，然后a就继续往后执行，b独自执行
